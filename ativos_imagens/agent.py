# ativos_imagens/agent.py
"""Agente de produ√ß√£o de assets digitais"""

# Carregamento autom√°tico de vari√°veis de ambiente
from dotenv import load_dotenv
load_dotenv()

# Importa√ß√µes expl√≠citas do ADK
from google.adk.agents import LlmAgent
from google.adk.tools import FunctionTool
import datetime
import os
import sys
import shutil
import tempfile
import time
import requests
import replicate
from typing import Optional, Dict

# Importar ferramentas
try:
    from .tools.lottie_programmatic import LottieProgrammaticGenerator
    lottie_available = True
except ImportError:
    lottie_available = False
    print("Aviso: Ferramenta Lottie n√£o dispon√≠vel. Instale python-lottie.")

try:
    from .tools.svg_generator import SVGGenerator
    svg_available = True
except ImportError:
    svg_available = False
    print("Aviso: Ferramenta SVG n√£o dispon√≠vel.")

try:
    from .tools.image_generator import ImageGenerator
    png_available = True
except ImportError:
    png_available = False
    print("Aviso: Ferramenta PNG n√£o dispon√≠vel.")

try:
    from .tools.asset_manager import AssetManager
    asset_manager_available = True
except ImportError:
    asset_manager_available = False
    print("Aviso: AssetManager n√£o dispon√≠vel.")

try:
    from .tools.mascot_animator import MascotAnimator
    mascot_animator_available = True
except ImportError:
    mascot_animator_available = False
    print("Aviso: Ferramenta MascotAnimator n√£o dispon√≠vel.")

# Debug: Verificar ambiente
print(f"Python version: {sys.version}")
print(f"Working directory: {os.getcwd()}")
print(f"__file__: {__file__ if '__file__' in globals() else 'Not defined'}")

# Verificar se tokens de API est√£o dispon√≠veis
google_key = os.getenv('GOOGLE_API_KEY')
replicate_token = os.getenv('REPLICATE_API_TOKEN')

if google_key:
    print("‚úÖ Google API Key carregada do .env")
else:
    print("‚ö†Ô∏è Google API Key n√£o encontrada no .env")

if replicate_token and replicate_token != 'sua_chave_replicate_aqui':
    print("‚úÖ Replicate API Token carregada do .env")
else:
    print("‚ö†Ô∏è Replicate API Token n√£o configurada no .env")
    print("   Configure sua chave em .env: REPLICATE_API_TOKEN=sua_chave_aqui")

# Sistema de controle de chamadas de API
API_CALL_TRACKER = {
    'recraft_calls': 0,
    'replicate_calls': 0,
    'max_calls_per_session': 10,
    'session_start': time.time()
}

def check_api_limit(api_type: str) -> bool:
    """Verifica se ainda podemos fazer chamadas de API."""
    total_calls = API_CALL_TRACKER.get('recraft_calls', 0) + API_CALL_TRACKER.get('replicate_calls', 0)
    
    if total_calls >= API_CALL_TRACKER['max_calls_per_session']:
        print(f"üõë Limite de API atingido ({total_calls} chamadas). Abortando opera√ß√£o.")
        return False
    
    return True

def reset_api_limits():
    """Reseta contadores de API (√∫til para testes ou novo dia)."""
    API_CALL_TRACKER.update({
        'recraft_calls': 0,
        'replicate_calls': 0,
        'session_start': time.time()
    })
    print("üîÑ Limites de API resetados")

class ErrorTracker:
    """Rastreia erros para evitar loops infinitos com erros persistentes."""
    def __init__(self):
        self.error_history = {}
        self.max_same_error = 2  # M√°ximo de vezes para o mesmo erro
    
    def _normalize_error(self, error_msg: str) -> str:
        """Normaliza mensagem de erro removendo partes vari√°veis."""
        # Remove n√∫meros, IDs e timestamps
        import re
        normalized = re.sub(r'\d+', 'X', error_msg)
        normalized = re.sub(r'[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}', 'UUID', normalized)
        
        # Identifica tipos comuns de erro
        if '402' in error_msg or 'Payment Required' in error_msg:
            return 'ERROR_402_PAYMENT_REQUIRED'
        elif '429' in error_msg or 'Rate Limit' in error_msg:
            return 'ERROR_429_RATE_LIMIT'
        elif 'timeout' in error_msg.lower():
            return 'ERROR_TIMEOUT'
        elif 'connection' in error_msg.lower():
            return 'ERROR_CONNECTION'
        
        return normalized[:100]  # Limita tamanho
    
    def should_retry(self, error_msg: str) -> bool:
        """Verifica se devemos tentar novamente ap√≥s este erro."""
        normalized = self._normalize_error(error_msg)
        
        # Contar ocorr√™ncias
        self.error_history[normalized] = self.error_history.get(normalized, 0) + 1
        
        # Se o mesmo erro ocorreu mais vezes que o permitido, parar
        if self.error_history[normalized] > self.max_same_error:
            print(f"‚ö†Ô∏è Erro persistente detectado: '{normalized}' (ocorreu {self.error_history[normalized]}x). Abortando tentativas.")
            return False
        
        return True


# Defini√ß√£o da ferramenta
def get_project_status() -> str:
    """Obt√©m o status atual do projeto de gera√ß√£o de ativos.
    
    Returns:
        str: Status formatado do projeto com data e hora atual
    """
    now = datetime.datetime.now()
    return f"""Status do Projeto - {now.strftime("%d/%m/%Y %H:%M:%S")}
    
Sistema: Gerador de Assets para Aplica√ß√£o Infantil
Arquitetura: Agente √önico com Ferramentas (AUF)

Ferramentas planejadas:
- Gera√ß√£o PNG (mascote PROF e sprites)
- Gera√ß√£o SVG (√≠cones e padr√µes)
- Gera√ß√£o MP3 (efeitos sonoros)
- Gera√ß√£o Lottie (anima√ß√µes)

Status: Agente base operacional - modo teste"""


# Fun√ß√£o orquestradora principal
def create_asset(asset_id: str) -> str:
    """Cria um ativo baseado em seu ID do invent√°rio.
    
    Args:
        asset_id: ID do ativo (ex: 'LOAD-01', 'UI-03', 'ICO-02')
    
    Returns:
        str: Status da cria√ß√£o com detalhes ou mensagem de erro
    """
    if not asset_manager_available:
        return "‚ùå Erro: AssetManager n√£o dispon√≠vel. Verifique a instala√ß√£o."
    
    try:
        # Inicializar gerenciador
        manager = AssetManager()
        
        # Carregar invent√°rio
        manager.load_asset_inventory()
        
        # Obter especifica√ß√µes do ativo
        spec = manager.get_asset_specification(asset_id)
        if not spec:
            return f"‚ùå Erro: Ativo '{asset_id}' n√£o encontrado no invent√°rio."
        
        # Verificar se podemos criar
        can_create, reason = manager.can_create_asset(asset_id)
        if not can_create:
            return f"""‚ùå N√£o posso criar o ativo '{asset_id}'.

üìã **Detalhes do Ativo:**
- Nome: {spec.get('filename')}
- Descri√ß√£o: {spec.get('description')}
- Tipo: {spec.get('type')}

‚ö†Ô∏è **Motivo:** {reason}

üí° **Alternativas:**
- Para √°udio (SFX): Use ferramentas como Audacity ou FL Studio
- Para imagens do mascote (MAS): Use Midjourney, DALL-E ou ilustrador
- Para gradientes PNG: Use Photoshop ou GIMP

üìå **Ativos que posso criar:**
- Anima√ß√µes Lottie program√°ticas (LOAD, FBK, ACH)
- Padr√µes e √≠cones SVG (UI, ICO)
- Molduras de badges (ACH)"""
        
        # Criar ativo baseado no tipo
        asset_type = spec.get('type')
        
        if asset_type == 'lottie_programmatic':
            result = _create_lottie_asset(asset_id, spec, manager)
        elif asset_type == 'lottie_mascote':
            result = _create_mascot_animation_asset(asset_id, spec, manager)
        elif asset_type == 'svg':
            result = _create_svg_asset(asset_id, spec, manager)
        elif asset_type in ['png_mascote', 'png_generico']:
            result = _create_png_asset(asset_id, spec, manager, remove_bg=True)
        else:
            return f"‚ùå Tipo '{asset_type}' ainda n√£o implementado."
        
        # Atualizar checklist se sucesso
        if "‚úÖ" in result:
            manager.update_checklist_status(asset_id, 'completed')
            
        return result
        
    except Exception as e:
        return f"‚ùå Erro ao criar ativo: {str(e)}"


def _create_lottie_asset(asset_id: str, spec: dict, manager: AssetManager) -> str:
    """Cria um ativo Lottie baseado nas especifica√ß√µes."""
    if not lottie_available:
        return "‚ùå Erro: Ferramenta Lottie n√£o dispon√≠vel. Instale com: pip install lottie"
    
    try:
        generator = LottieProgrammaticGenerator()
        
        # Extrair par√¢metros
        params = spec.get('parameters', {})
        duration = params.get('duration', 1.0)
        loop = params.get('loop', False)
        style = params.get('style', '')
        
        # Determinar tipo e estilo da anima√ß√£o
        category = spec.get('category')
        if category == 'LOAD':
            anim_type = 'loading'
        elif category == 'FBK':
            anim_type = 'feedback'
        elif category == 'ACH':
            anim_type = 'achievement'
        else:
            anim_type = 'loading'
        
        # Se n√£o tem estilo definido, inferir do nome/descri√ß√£o
        if not style:
            if 'spinner' in spec.get('filename', ''):
                style = 'spinner'
            elif 'bounce' in spec.get('description', '').lower():
                style = 'bounce'
            elif 'wave' in spec.get('description', '').lower():
                style = 'wave'
            elif 'checkmark' in spec.get('filename', ''):
                style = 'checkmark'
            elif 'ripple' in spec.get('filename', ''):
                style = 'ripple'
            elif 'shake' in spec.get('description', '').lower():
                style = 'shake'
            elif 'pulse' in spec.get('description', '').lower():
                style = 'pulse'
            elif 'unlock' in spec.get('filename', ''):
                style = 'unlock'
            elif 'level_up' in spec.get('filename', ''):
                style = 'level_up'
            elif 'star_burst' in spec.get('filename', ''):
                style = 'star_burst'
            elif 'thinking' in spec.get('description', '').lower():
                style = 'thinking'
            elif 'camera' in spec.get('description', '').lower():
                style = 'camera'
            elif 'ai' in spec.get('description', '').lower() or 'neural' in spec.get('description', '').lower():
                style = 'ai'
        
        # Gerar anima√ß√£o
        file_path = generator.generate_animation(
            animation_type=anim_type,
            style=style,
            duration=duration,
            loop=loop
        )
        
        # Mover para local correto
        target_path = manager.get_asset_path(asset_id)
        if target_path:
            os.makedirs(target_path.parent, exist_ok=True)
            import shutil
            shutil.move(file_path, str(target_path))
            file_path = str(target_path)
        
        # Obter tamanho
        file_size = os.path.getsize(file_path)
        size_kb = file_size / 1024
        
        return f"""‚úÖ Ativo Lottie criado com sucesso!

üÜî **ID:** {asset_id}
üìÅ **Arquivo:** {spec.get('filename')}
üìÇ **Local:** {file_path}
üìä **Tamanho:** {size_kb:.1f} KB
üìù **Descri√ß√£o:** {spec.get('description')}
üé¨ **Tipo/Estilo:** {anim_type}/{style}
‚è±Ô∏è **Dura√ß√£o:** {duration}s
üîÑ **Loop:** {'Sim' if loop else 'N√£o'}

‚ú® **Status do Checklist:** Atualizado para ‚úÖ Criado pelo agente"""
        
    except Exception as e:
        return f"‚ùå Erro ao gerar Lottie: {str(e)}"


def _create_png_asset(asset_id: str, spec: dict, manager: AssetManager, remove_bg: bool = True, return_path: bool = False) -> str:
    """
    Cria um ativo PNG baseado nas especifica√ß√µes.

    Args:
        asset_id: O ID do ativo.
        spec: As especifica√ß√µes do ativo do AssetManager.
        manager: A inst√¢ncia do AssetManager.
        remove_bg: Se True, remove o fundo da imagem gerada.
        return_path: Se True, retorna apenas o caminho do arquivo ao inv√©s da mensagem formatada.
    
    Returns:
        Se return_path=True: Caminho absoluto do arquivo PNG.
        Se return_path=False: Mensagem formatada de sucesso/erro.
    """
    if not png_available:
        return "‚ùå Erro: Ferramenta de Gera√ß√£o PNG n√£o est√° dispon√≠vel."
    
    try:
        generator = ImageGenerator()
        
        asset_type = spec.get('type').replace('png_', '')
        prompt_details = spec.get('prompt_details', {})
        
        if asset_type == 'generico':
            prompt_details['description'] = spec.get('description', 'a simple generic asset')

        prompt_details['filename_base'] = spec.get('filename', 'asset').replace('.png', '')

        model_name = "black-forest-labs/flux-schnell"
        
        file_path = generator.generate_png(
            asset_type=asset_type,
            prompt_details=prompt_details,
            model_name=model_name,
            remove_bg=remove_bg
        )
        
        target_path = manager.get_asset_path(asset_id)
        if target_path:
            os.makedirs(target_path.parent, exist_ok=True)
            shutil.move(file_path, str(target_path))
            file_path = str(target_path)
        
        file_size = os.path.getsize(file_path) / 1024
        
        if return_path:
            return file_path
        
        return f"""‚úÖ Ativo PNG criado com sucesso!

üÜî **ID:** {asset_id}
üìÅ **Arquivo:** {spec.get('filename')}
üìÇ **Local:** {file_path}
üìä **Tamanho:** {file_size:.1f} KB

‚ú® **Status do Checklist:** Atualizado para ‚úÖ Criado pelo agente"""
        
    except Exception as e:
        return f"‚ùå Erro ao gerar PNG para '{asset_id}': {str(e)}"


def _prepare_svg_prompt(spec: dict) -> str:
    """
    Prepara prompt otimizado para gera√ß√£o de SVG baseado no tipo de ativo.
    """
    description = spec.get('description', '')
    category = spec.get('category', '')
    
    # Base prompt
    base = f"{description}, vector art, clean lines, minimalist design"
    
    # Adicionar modificadores por categoria
    if category == 'ICO':
        return f"{base}, icon style, simple shapes, bold colors, white background"
    elif category == 'UI':
        return f"{base}, UI element, flat design, modern, scalable"
    elif 'badge' in spec.get('filename', ''):
        return f"{base}, badge frame, decorative border, achievement style"
    else:
        return f"{base}, illustration, colorful, professional"


def _is_valid_svg(content: str) -> bool:
    """Valida se o conte√∫do √© um SVG v√°lido."""
    if not content:
        return False
    
    # Verificar se √© string e cont√©m tags SVG
    if isinstance(content, str):
        if '<svg' in content and '</svg>' in content:
            return True
        # Se for URL, precisamos baixar primeiro
        elif content.startswith('http'):
            return True
        
    return False


def _save_svg_from_recraft(svg_content: str, asset_id: str, spec: dict, manager: AssetManager) -> str:
    """Salva SVG gerado pelo Recraft no local correto."""
    try:
        target_path = manager.get_asset_path(asset_id)
        os.makedirs(target_path.parent, exist_ok=True)
        
        # Se for URL, baixar conte√∫do
        if svg_content.startswith('http'):
            response = requests.get(svg_content)
            response.raise_for_status()
            svg_content = response.text
        
        # Salvar arquivo
        with open(str(target_path), 'w', encoding='utf-8') as f:
            f.write(svg_content)
            
        file_size = os.path.getsize(target_path) / 1024
        
        return f"""‚úÖ Ativo SVG criado com sucesso via Recraft!
        
üÜî **ID:** {asset_id}
üìÅ **Arquivo:** {spec.get('filename')}
üìÇ **Local:** {target_path}
üìä **Tamanho:** {file_size:.1f} KB
üöÄ **M√©todo:** Gera√ß√£o direta (Recraft-20b-svg)

‚ú® **Status do Checklist:** Atualizado para ‚úÖ Criado pelo agente"""
        
    except Exception as e:
        raise RuntimeError(f"Erro ao salvar SVG do Recraft: {str(e)}")


def _try_recraft_svg_generation(spec: dict, max_attempts: int = 3) -> Optional[str]:
    """
    Tenta gerar SVG via Recraft com retry logic.
    
    Returns:
        String com conte√∫do SVG ou None se falhar
    """
    error_tracker = ErrorTracker()
    
    for attempt in range(1, max_attempts + 1):
        # Verificar limite de API antes de tentar
        if not check_api_limit('recraft'):
            print("üõë Limite de API atingido. Abortando gera√ß√£o via Recraft.")
            return None
            
        try:
            print(f"Tentativa {attempt}/{max_attempts}: Gerando SVG via Recraft...")
            
            # Preparar prompt otimizado para SVG
            prompt = _prepare_svg_prompt(spec)
            
            # Incrementar contador ANTES da chamada (para contar tentativas)
            API_CALL_TRACKER['recraft_calls'] += 1
            
            output = replicate.run(
                "recraft-ai/recraft-20b-svg",
                input={
                    "size": "1024x1024",  # Tamanho v√°lido para Recraft
                    "style": "vector_illustration/cartoon", 
                    "prompt": prompt,
                    "aspect_ratio": "1:1"
                }
            )
            
            # Validar se √© SVG v√°lido
            if _is_valid_svg(output):
                print(f"‚úÖ SVG gerado com sucesso na tentativa {attempt}")
                return output
                
        except Exception as e:
            error_msg = str(e)
            print(f"‚ùå Tentativa {attempt} falhou: {error_msg}")
            
            # Verificar se devemos continuar tentando
            if not error_tracker.should_retry(error_msg):
                print("üõë Abortando tentativas devido a erro persistente")
                return None
                
            if attempt < max_attempts:
                time.sleep(2 ** attempt)  # Backoff exponencial (2s, 4s)
                
    return None


def _create_mascot_animation_asset(asset_id: str, spec: dict, manager: AssetManager) -> str:
    """Cria uma anima√ß√£o Lottie do mascote."""
    if not mascot_animator_available:
        return "‚ùå Erro: Ferramenta de Anima√ß√£o do Mascote n√£o est√° dispon√≠vel."

    try:
        animator = MascotAnimator()
        
        # Detalhes para gerar o PNG base
        prompt_details_png = spec.get('prompt_details', {})
        # Prompt para a anima√ß√£o
        animation_prompt = spec.get('animation_prompt', 'standing still and breathing gently')
        
        target_path = manager.get_asset_path(asset_id)
        if not target_path:
            raise ValueError(f"Caminho de destino n√£o encontrado para {asset_id}")

        os.makedirs(target_path.parent, exist_ok=True)

        result_path = animator.create_mascot_animation_v2(
            prompt_details=prompt_details_png,
            animation_prompt=animation_prompt,
            output_path=str(target_path),
            output_format="lottie"  # Usar formato .lottie por padr√£o
        )
        
        file_size = os.path.getsize(result_path) / 1024

        return f"""‚úÖ Anima√ß√£o do mascote criada com sucesso!

üÜî **ID:** {asset_id}
üìÅ **Arquivo:** {os.path.basename(result_path)}
üìÇ **Local:** {result_path}
üìä **Tamanho:** {file_size:.1f} KB
üìù **Descri√ß√£o:** {spec.get('description')}
üé¨ **Prompt de Anima√ß√£o:** {animation_prompt}

‚ú® **Status do Checklist:** Atualizado para ‚úÖ Criado pelo agente"""
        
    except Exception as e:
        return f"‚ùå Erro ao gerar anima√ß√£o do mascote para '{asset_id}': {str(e)}"


def _create_svg_via_png_pipeline(asset_id: str, spec: dict, manager: AssetManager) -> str:
    """
    Pipeline de fallback: PNG ‚Üí SVG (implementa√ß√£o anterior).
    Usado apenas quando Recraft falha.
    """
    print(f"INFO: Usando pipeline de fallback PNG‚ÜíSVG para {asset_id}...")
    
    with tempfile.TemporaryDirectory() as tmpdir:
        try:
            # ETAPA 1: Gerar PNG base diretamente com ImageGenerator
            print(f"ETAPA 1/3: Gerando imagem raster base para {asset_id}...")
            
            generator = ImageGenerator()
            
            # Preparar detalhes do prompt baseados na descri√ß√£o do ativo
            prompt_details = {
                'description': spec.get('description', 'simple geometric shape'),
                'filename_base': f"temp_{asset_id.lower()}"
            }
            
            # Gerar PNG SEM remover fundo (importante para vetoriza√ß√£o)
            temp_png_path = generator.generate_png(
                asset_type='generico',
                prompt_details=prompt_details,
                model_name="black-forest-labs/flux-schnell",
                remove_bg=False  # Cr√≠tico: n√£o remover fundo para melhor vetoriza√ß√£o
            )
            
            print(f"Imagem base gerada em: {temp_png_path}")
            
            # ETAPA 2: Mover PNG para diret√≥rio tempor√°rio (para limpeza autom√°tica)
            final_temp_path = os.path.join(tmpdir, f"{asset_id}_base.png")
            shutil.move(temp_png_path, final_temp_path)
            print(f"Imagem movida para diret√≥rio tempor√°rio: {final_temp_path}")

            # ETAPA 3: Vetorizar PNG‚ÜíSVG
            print(f"ETAPA 2/3: Vetorizando {final_temp_path}...")
            svg_generator = SVGGenerator()
            
            target_path = manager.get_asset_path(asset_id)
            if not target_path:
                raise ValueError(f"Caminho de destino n√£o encontrado para {asset_id}")

            os.makedirs(target_path.parent, exist_ok=True)
            
            # Usar o m√©todo de vetoriza√ß√£o da SVGGenerator
            svg_generator.vectorize_and_save(
                input_image_path=final_temp_path,
                output_svg_path=str(target_path)
            )
            print(f"SVG final salvo em: {target_path}")

            print(f"--- Pipeline SVG para {asset_id} conclu√≠do com sucesso! ---")
            
            # Obter tamanho do arquivo final
            file_size = os.path.getsize(target_path) / 1024
            
            return f"""‚úÖ Ativo SVG criado com sucesso!

üÜî **ID:** {asset_id}
üìÅ **Arquivo:** {spec.get('filename')}
üìÇ **Local:** {target_path}
üìä **Tamanho:** {file_size:.1f} KB
üìù **Descri√ß√£o:** {spec.get('description')}
üîß **M√©todo:** Pipeline PNG‚ÜíSVG (fallback)

‚ú® **Status do Checklist:** Atualizado para ‚úÖ Criado pelo agente"""

        except Exception as e:
            print(f"ERRO no pipeline SVG para {asset_id}: {e}")
            return f"‚ùå Erro ao gerar SVG para '{asset_id}': {str(e)}"


def _create_svg_asset(asset_id: str, spec: dict, manager: AssetManager) -> str:
    """
    Cria SVG com sistema de prioridades:
    1. Tenta Recraft-20b-svg (3 tentativas)
    2. Fallback para pipeline PNG‚ÜíSVG se necess√°rio
    """
    if not svg_available:
        return "‚ùå Erro: Ferramenta SVG n√£o est√° dispon√≠vel."

    print(f"--- Iniciando Gera√ß√£o de SVG para: {asset_id} ---")
    
    # PRIORIDADE 1: Tentar gera√ß√£o direta via Recraft
    svg_content = _try_recraft_svg_generation(spec, max_attempts=3)
    
    if svg_content:
        # Salvar SVG gerado diretamente
        try:
            return _save_svg_from_recraft(svg_content, asset_id, spec, manager)
        except Exception as e:
            print(f"AVISO: Falha ao salvar SVG do Recraft: {e}")
            print("Tentando pipeline de fallback...")
    
    # PRIORIDADE 2: Fallback para pipeline PNG‚ÜíSVG
    if not png_available:
        return "‚ùå Erro: Recraft falhou e ferramenta PNG n√£o est√° dispon√≠vel para fallback."
    
    return _create_svg_via_png_pipeline(asset_id, spec, manager)


def check_asset_inventory() -> str:
    """Verifica o invent√°rio de ativos e retorna estat√≠sticas.
    
    Returns:
        str: Relat√≥rio do invent√°rio com estat√≠sticas
    """
    if not asset_manager_available:
        return "‚ùå Erro: AssetManager n√£o dispon√≠vel."
    
    try:
        manager = AssetManager()
        manager.load_asset_inventory()
        manager.load_checklist_status()
        
        # Obter ativos que podemos criar
        creatable = manager.get_creatable_assets()
        
        # Contar por status
        total_creatable = sum(len(assets) for assets in creatable.values())
        completed = sum(1 for status in manager.checklist_status.values() 
                       if status.get('completed'))
        
        # Listar ativos por tipo
        report = f"""üìä **Invent√°rio de Ativos - Relat√≥rio**

üìà **Estat√≠sticas:**
- Total de ativos no invent√°rio: {len(manager.asset_specs)}
- Ativos que posso criar: {total_creatable}
- Ativos j√° criados: {completed}
- Ativos pendentes: {total_creatable - completed}

üõ†Ô∏è **Capacidades do Agente:**

‚úÖ **Posso criar ({total_creatable} ativos):**
"""
        
        # Listar Lottie
        if creatable.get('lottie_programmatic'):
            report += f"\nüé¨ **Anima√ß√µes Lottie Program√°ticas ({len(creatable['lottie_programmatic'])}):**\n"
            for asset_id in sorted(creatable['lottie_programmatic']):
                spec = manager.asset_specs.get(asset_id, {})
                status = "‚úÖ" if manager.checklist_status.get(asset_id, {}).get('completed') else "‚è≥"
                report += f"  {status} {asset_id}: {spec.get('filename', 'N/A')}\n"
        
        # Listar SVG
        if creatable.get('svg'):
            report += f"\nüé® **Arquivos SVG ({len(creatable['svg'])}):**\n"
            for asset_id in sorted(creatable['svg']):
                spec = manager.asset_specs.get(asset_id, {})
                status = "‚úÖ" if manager.checklist_status.get(asset_id, {}).get('completed') else "‚è≥"
                report += f"  {status} {asset_id}: {spec.get('filename', 'N/A')}\n"
        
        report += """
‚ùå **N√£o posso criar (requerem ferramentas externas):**
- üéµ Efeitos Sonoros (SFX): 9 arquivos MP3
- ü¶∏ Imagens do Mascote (MAS): 10 arquivos PNG
- üéûÔ∏è Anima√ß√µes do Mascote (MAS): 5 anima√ß√µes Lottie vetorizadas
- üåà Gradientes e Part√≠culas (UI): 4 arquivos PNG
- üé® Elementos Tem√°ticos (THM): 5 arquivos SVG complexos

üí° **Como usar:**
- Para criar um ativo: "Crie o ativo LOAD-01"
- Para criar todos de um tipo: "Crie todas as anima√ß√µes de loading"
- Para ver detalhes: "Mostre detalhes do ativo UI-03"
"""
        
        return report
        
    except Exception as e:
        return f"‚ùå Erro ao verificar invent√°rio: {str(e)}"


try:
    # Agente principal com tratamento de erro
    root_agent = LlmAgent(
        name="asset_production_orchestrator",
        model="gemini-1.5-flash-latest",
        instruction="""Voc√™ √© um assistente orquestrador para a produ√ß√£o de assets digitais.
Sua principal ferramenta √© `create_asset(asset_id)`. Use-a para criar qualquer ativo solicitado pelo usu√°rio,
fornecendo o ID do ativo (ex: 'MAS-06', 'ICO-01').
Voc√™ tamb√©m pode usar `check_asset_inventory()` para ver a lista de todos os ativos e seus status.
""",
        tools=[
            FunctionTool(create_asset),
            FunctionTool(check_asset_inventory),
            FunctionTool(get_project_status)
        ]
    )
    print("Agent created successfully!")
except Exception as e:
    print(f"Error creating agent: {type(e).__name__}: {e}")
    # Criar agente m√≠nimo como fallback
    root_agent = LlmAgent(
        name="root_agent",
        model="gemini-1.5-flash-latest",
        instruction="Voc√™ √© um assistente de produ√ß√£o de assets digitais. (Modo fallback - sem ferramentas)"
    )
    print("Fallback agent created")